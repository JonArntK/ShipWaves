#pragma kernel ComputeWaterSurfaceKernel

#include "FiniteWaterDispersionRelation.hlsl"   // For testing
#include "TestSinWave.hlsl" // For testing

#include "ComputeElevationGlobal.hlsl"
#include "GenerateMesh.hlsl"
#include "VesselGeometryStruct.hlsl"
#include "VesselPathStruct.hlsl"
#include "WallReflection.hlsl"

#define GROUP_SIZE_X 64
#define GROUP_SIZE_Y 1
#define GROUP_SIZE_Z 1

// Define buffers for storing the vertices, normals and texture coordinates of the mesh.
RWByteAddressBuffer _VertexBuffer;
RWByteAddressBuffer _NormalBuffer;
RWByteAddressBuffer _TexcoordBuffer;

RWStructuredBuffer<float2> _Test;  // TO BE REMOVED!

// Mesh properties.
int _QuadCount, _XQuadCount, _ZQuadCount, _XOrigin, _ZOrigin;
float _Time, _XStep, _ZStep;

// Number of vessels.
int _NumVessels;

// Vessel geometry properties.
StructuredBuffer<float3> _VesselCoord;
int2 _VesselNxNy;

// Vessel path properties.
StructuredBuffer<float2> _VesselPathCoord;
StructuredBuffer<float> _VesselPathTime, _VesselPathHeading, _VesselPathDepth;
int _VesselPathNumPoints;

// Stationary points for use in computation of ship waves in finite water depth.
// Pre-calculated to increase performance.
StructuredBuffer<float2> _FiniteWaterStationaryPoints;
float4 _FnhInfo, _HInfo, _AlphaInfo;

// Wall properties
StructuredBuffer<float4> _Walls;
int _NumWalls;

float ComputeElevation(Vertex v, VesselGeometryStruct vgs, VesselPathStruct vps)
{
    float elevation = 0.0;
    for (int i = 0; i < _NumVessels; i++)
    {
        elevation += ComputeShipWaveElevationGlobal(v.position.xz, i, vgs, vps, false, _Walls, 0, _NumWalls);
        elevation += ComputeWallReflection(v.position.xz, i, vgs, vps, _Walls, _NumWalls);
        
        float2 source = float2(-1000, -1000);
        //elevation += ComputeShipElevationGlobalSinWave(v.position.xz, source, false, _Walls, _NumWalls, 0, 0);
        //elevation += ComputeWallReflectionSinWave(v.position.xz, source, _Walls, _NumWalls, 0, 0);

    }
    return elevation;
}

void test(VesselPathStruct vps)
{
    float fnh = 0.95;
    float fn = 0.677;
    float U = fn * sqrt(9.81 * 8.0);
    float h = pow(U / fnh, 2.0) / 9.81;
    
    float alpha = 0; 
    
    //for (int i = 0; i < 20; i++)
    //{
    //    alpha += PI * 0.5 / 20;
        
    //    float2 theta = GetPointsOfStationaryPhaseFiniteWaterBuffer(vps, fnh, h, alpha);
    //    float2 theta2 = GetPointsOfStationaryPhaseFiniteWater(float2(-PI * 0.5 + 0.02, 0.00), fnh, h, alpha);
        
    //    if (abs(theta.x - theta2.x) > 0.1)
    //    {
    //        int fnhIndex = GetIndex(fnh, vps.fnhInfo);
    //        int hIndex = GetIndex(h, vps.hInfo);
    //        int alphaIndex = GetIndex(alpha, vps.alphaInfo);
            
    //        _Test[0] = float2(abs(theta.x - theta2.x), fnh);
    //        _Test[1] = float2(h, alpha);
    //    }
    //}
    
    alpha = 0.7853982; //1.284829;
    
    float2 theta = GetPointsOfStationaryPhaseFiniteWaterBuffer(vps, fnh, h, alpha);
    float2 theta2 = GetPointsOfStationaryPhaseFiniteWater(float2(-PI * 0.5 + 0.02, 0.00), fnh, h, alpha);
        
    int fnhIndex = GetIndex(fnh, vps.fnhInfo);
    int hIndex = GetIndex(h, vps.hInfo);
    int alphaIndex = GetIndex(alpha, vps.alphaInfo);

    int index = Matrix3DTo1D(fnhIndex, hIndex, alphaIndex, vps.fnhInfo.w, vps.hInfo.w, vps.alphaInfo.w);
    
    int3 indices = Matrix1DTo3D(index, _FnhInfo.w, _HInfo.w, _AlphaInfo.w);
    float fnh2 = _FnhInfo.x + indices.x * _FnhInfo.z;
    float h2 = _HInfo.x + indices.y * _HInfo.z;
    float alpha2 = _AlphaInfo.x + indices.z * _AlphaInfo.z;
    
    _Test[0] = float2(fnh2, h2); //theta;       // (1f, 1f)
    _Test[1] = float2(alpha2, (float) index); //theta2;      // (-0.2848, -0.2868)
    
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, GROUP_SIZE_Z)]
void ComputeWaterSurfaceKernel(uint3 threadID : SV_DispatchThreadID)
{
    // Initialize structs.
    VesselGeometryStruct vesselGeometryInfo = InitializeVesselGeometry(_VesselCoord, _VesselNxNy);
    VesselPathStruct vesselPathInfo = InitializeVesselPath(_VesselPathNumPoints, _VesselPathCoord, _VesselPathTime, _VesselPathHeading, _VesselPathDepth,
        _FiniteWaterStationaryPoints, _FnhInfo, _HInfo, _AlphaInfo);

    uint id = threadID.x + threadID.y * GROUP_SIZE_X;
    if ((int) id >= _QuadCount)
        return;
    uint idx1 = id * 6;
    uint idx2 = id * 6 + 1;
    uint idx3 = id * 6 + 2;
    uint idx4 = id * 6 + 3;
    uint idx5 = id * 6 + 4;
    uint idx6 = id * 6 + 5;

    // Generate quad.
    Vertex v1 = GenerateQuad(idx1, _XQuadCount, _XStep, _ZStep, _XOrigin, _ZOrigin);
    Vertex v2 = GenerateQuad(idx2, _XQuadCount, _XStep, _ZStep, _XOrigin, _ZOrigin);
    Vertex v3 = GenerateQuad(idx3, _XQuadCount, _XStep, _ZStep, _XOrigin, _ZOrigin);
    Vertex v6 = GenerateQuad(idx6, _XQuadCount, _XStep, _ZStep, _XOrigin, _ZOrigin);

    // Compute surface elevation.
    v1.position.y = ComputeElevation(v1, vesselGeometryInfo, vesselPathInfo);
    v2.position.y = ComputeElevation(v2, vesselGeometryInfo, vesselPathInfo);
    v3.position.y = ComputeElevation(v3, vesselGeometryInfo, vesselPathInfo);
    v6.position.y = ComputeElevation(v6, vesselGeometryInfo, vesselPathInfo);

    // ----- Triangular mesh from quads -----
    // Quads are generated from the 'id' in the order displayed below.
    //    p3, p5        p6
    //       ___________
    //      |\          |
    //      |  \        |
    //      |    \      |
    //      |      \    |
    //      |        \  |
    //      |__________\|
    //     p1           p2, p4
    //
    // Hence triangles are made as (p1, p2, p3) and (p4, p5, p6),
    // which is equivalent to      (p1, p2, p3) and (p2, p3, p6),
    // avoiding the computation of p4 and p5.

    StoreTriangle(idx1, idx2, idx3, v1, v3, v2, _VertexBuffer, _NormalBuffer, _TexcoordBuffer);
    StoreTriangle(idx4, idx5, idx6, v2, v3, v6, _VertexBuffer, _NormalBuffer, _TexcoordBuffer);
    
    test(vesselPathInfo);

}

